#!/bin/bash
set -e

#BSUB header sutff

# General job options
JSUB_FLAG_TIMESTAMP=false
JSUB_FLAG_CHECK_VERSIONS=true

# Log and summary file paths
JSUB_THIS_JOB="$0" # Note: using this will not work on the HPC, "$0" is for testing only, provide the actual file name when running LSF jobs.
JSUB_LOG_FILE="$1"
JSUB_SUMMARY_COMPLETED="$2"
JSUB_SUMMARY_INCOMPLETE="$3"

## job_processing parses the job file, writes to log and summary files, and calls version control functions on blocks of code.
# Function allowing job script termination
trap "exit 1" TERM
export TOP_PID=$$
function kill_this_job {
  echo "Terminating job $1"
  kill -s TERM $TOP_PID
}
# Tag variables
JSUB_BEGIN_JOB_TAG="#JSUB<begin_job>"
JSUB_CHECKPOINT_TAG="jcheck_"
JSUB_FINISH_JOB_TAG="#JSUB<finish_job>"
# Job processing variables
JSUB_PREVIOUS_END=0
JSUB_FLAG_FAIL=false
# Writes to log and summray (completed and incomplete) files
function process_job {
  local dateTime=""
  [ ${JSUB_FLAG_TIMESTAMP} = true ] && dateTime=`date +%Y%m%d_%H%M%S`
  rm -f ${JSUB_SUMMARY_INCOMPLETE} # Clean out the summary.incomplete file so that it is ready to accept a new text from the start
  ## Loop over this job file and process lines
  local jline=0 # Line number within the job commands section
  local flagInJob=false
  local flagBlockEnded=false
  while read -r line || [[ -n "$line" ]]; do
    ## Check if we have entered or left the job commands section
    if [[ ${line} == ${JSUB_BEGIN_JOB_TAG}* ]]; then
      flagInJob=true
      continue
    elif [[ ${line} == ${JSUB_FINISH_JOB_TAG}* ]]; then
      jline=$((jline+1))
      flagInJob=false
    fi
    ## Only process the line if it originated form a summary file
    if [ ${flagInJob} = true ]; then
      jline=$((jline+1)) # Increment line numbers inside job
      ## Determin current line type
      if [ ${flagBlockEnded} = false ]; then
        if [ ${jline} -le ${JSUB_PREVIOUS_END} ]; then # A line before the block of code currently being executed
          : # do nothing
        elif [ ${jline} -gt ${JSUB_PREVIOUS_END} ]; then # A line within the block of code currently being executed
          ## Check if this line corresponds to the end of a block
          if [[ ${line} == ${JSUB_CHECKPOINT_TAG}* ]] || [[ ${line} == ${JSUB_FINISH_JOB_TAG}* ]]; then
            flagBlockEnded=true
            JSUB_PREVIOUS_END=${jline} # Update line number of last block end
          fi
          ## Write to log and summary files
          if [ ${JSUB_FLAG_FAIL} = false ]; then
            echo "$dateTime completed - "${line} >> ${JSUB_LOG_FILE}
            echo ${line} >> ${JSUB_SUMMARY_COMPLETED}
          else
            echo "$dateTime incomplete - "${line} >> ${JSUB_LOG_FILE}
            echo ${line} >> ${JSUB_SUMMARY_INCOMPLETE}
          fi
        fi
      else # A line after the block of code that has just been executed
        echo ${line} >> ${JSUB_SUMMARY_INCOMPLETE}
      fi
    fi
  done < ${JSUB_THIS_JOB}
  [ ${JSUB_FLAG_FAIL} = true ] && kill_this_job ${JSUB_THIS_JOB} # Kill the job if a checkpoint fail occured (but let this function do logging etc first)
  return 0
}

# Attempts to obtain version information about tools and scripts used in a block of bash code.
function check_versions {
  echo "Running check_versions"
}

# Contents inserted from other files (this section is intended to be used only for functions):
# --- From file: jlang_function_test_files/dummy_bash_functions/dummy1.sh
function dummy1 {
echo Running_dummy_function_1 >> ${JSUB_LOG_FILE}
}
# --- From file: jlang_function_test_files/dummy_bash_functions/dummy2.sh
function dummy2 {
echo Running_dummy_function_2 >> ${JSUB_LOG_FILE}
}
function dummy2_1 {
echo Running_dummy_function_2_1 >> ${JSUB_LOG_FILE}
}
# --- From file: jlang_function_test_files/dummy_bash_functions/dummy3.sh
function dummy3 {
echo Running_dummy_function_3 >> ${JSUB_LOG_FILE}
}

function jcheck_resume {
  echo "Running jcheck_resume $@" >> ${JSUB_LOG_FILE}
  process_job "YYYYMMDD_HHMMSS"
}

#JSUB<begin_job>
#JGROUP second first third fourth fifth
echo "cmd 21" >> ${JSUB_LOG_FILE}
dummy1
jcheck_resume
#BSUB -J jobID
echo "cmd 22" >> ${JSUB_LOG_FILE}
dummy2
jcheck_resume
dummy2_1
#BSUB -o out.pj.output
echo "cmd 23" >> ${JSUB_LOG_FILE}
jcheck_resume
dummy3
#BSUB -e out.pj.error
jcheck_resume
echo "final executed command" >> ${JSUB_LOG_FILE}
#JSUB<finish_job>

# Finalise job
process_job

# EOF 
