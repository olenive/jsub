#!/bin/bash
set -eu

#BSUB -w 'done("summaryPrefix_sample0003A_root")'
#BSUB -J summaryPrefix_sample0003A_first
#BSUB -e summaryPrefix_sample0003A_first.error
#BSUB -o summaryPrefix_sample0003A_first.output
#BSUB -P prepay-houlston
#BSUB -q short


# Job file variables:
JSUB_PATH_TO_THIS_JOB="/scratch/cancgene/olenive/jsub/integration_tests/jgroup_checkpoints/generated_files/jobs/jobPrefix_summaryPrefix_sample0003A_first.lsf"
JSUB_JOB_ID="summaryPrefix_sample0003A"
JSUB_LOG_FILE="jobs/jobPrefix_summaryPrefix_sample0003A.log"
JSUB_SUMMARY_COMPLETED="jobs/jobPrefix_summaryPrefix_sample0003A.summary.completed"
JSUB_SUMMARY_INCOMPLETE="jobs/jobPrefix_summaryPrefix_sample0003A.summary.incomplete"
JSUB_VERSION_CONTROL=true
JSUB_JOB_TIMESTAMP=false

# Contents inserted from other files (this section is intended to be used only for functions):

# --- From file: /scratch/cancgene/olenive/jsub/common_functions/jcheck_file_not_empty.sh
function file_contains_nonwhitespace {
  while read -r line || [[ -n "$line" ]]; do
    if [[ "$line" = *[![:space:]]* ]]; then
      echo "yes"
      return 0
    fi
  done < "$1"
  echo "no"
}
function jcheck_file_not_empty {
  local dateTime=""
  [[ ${JSUB_JOB_TIMESTAMP} = true ]] && dateTime=`date +%Y%m%d_%H%M%S`
  for var in "$@"; do
    if [[ ! -s "$var" ]] || [[ $(file_contains_nonwhitespace "$var") = "no" ]]; then
      JSUB_FLAG_FAIL=true
      echo "$dateTime ""$JSUB_JOB_ID"" - Failed checkpoint jcheck_file_not_empty due to empty (or whitespace) file: ""$var"
      echo "$dateTime ""$JSUB_JOB_ID"" - Failed checkpoint jcheck_file_not_empty due to empty (or whitespace) file: ""$var" >> ${JSUB_LOG_FILE}
    else
      echo "$dateTime ""$JSUB_JOB_ID"" - Passed checkpoint jcheck_file_not_empty for file: ""$var" >> ${JSUB_LOG_FILE}
    fi
  done
}
# --- From file: /scratch/cancgene/olenive/jsub/common_functions/job_processing.sh
## job_processing parses the job file, writes to log and summary files, and calls version control functions.
# Function allowing job script termination
trap "exit 1" TERM
export TOP_PID=$$
function kill_this_job {
  echo "Terminating job $1"
  kill -s TERM $TOP_PID
}
# Tag variables
JSUB_BEGIN_JOB_TAG="#JSUB<begin-job>"
JSUB_CHECKPOINT_TAG="jcheck_"
JSUB_FINISH_JOB_TAG="#JSUB<finish-job>"
# Job processing variables
JSUB_PREVIOUS_END=0
JSUB_FLAG_FAIL=false
# Writes to log and summray (completed and incomplete) files
function process_job {
  local dateTime=""
  [[ ${JSUB_JOB_TIMESTAMP} = true ]] && dateTime=`date +%Y%m%d_%H%M%S`
  rm -f ${JSUB_SUMMARY_INCOMPLETE} # Clean out the summary.incomplete file so that it is ready to accept a new text from the start
  ## Loop over this job file and process lines
  local jline=0 # Line number within the job commands section
  local flagInJob=false
  local flagBlockEnded=false
  while read -r line || [[ -n "$line" ]]; do
    ## Check if we have entered or left the job commands section
    if [[ ${line} == ${JSUB_BEGIN_JOB_TAG}* ]]; then
      flagInJob=true
      continue
    elif [[ ${line} == ${JSUB_FINISH_JOB_TAG}* ]]; then
      jline=$((jline+1))
      flagInJob=false
    fi
    ## Only process the line if it originated form a summary file
    if [ ${flagInJob} = true ]; then
      jline=$((jline+1)) # Increment line numbers inside job
      ## Determin current line type
      if [ ${flagBlockEnded} = false ]; then
        if [ ${jline} -le ${JSUB_PREVIOUS_END} ]; then # A line before the block of code currently being executed
          : # do nothing
        elif [ ${jline} -gt ${JSUB_PREVIOUS_END} ]; then # A line within the block of code currently being executed
          ## Check if this line corresponds to the end of a block
          if [[ ${line} == ${JSUB_CHECKPOINT_TAG}* ]] || [[ ${line} == ${JSUB_FINISH_JOB_TAG}* ]]; then
            flagBlockEnded=true
            JSUB_PREVIOUS_END=${jline} # Update line number of last block end
          fi
          ## Write to log and summary files
          if [ ${JSUB_FLAG_FAIL} = false ]; then
            echo "$dateTime ""$JSUB_JOB_ID"" completed - "${line} >> ${JSUB_LOG_FILE}
            echo ${line} >> ${JSUB_SUMMARY_COMPLETED}
          else
            echo "$dateTime ""$JSUB_JOB_ID"" incomplete - "${line} >> ${JSUB_LOG_FILE}
            echo ${line} >> ${JSUB_SUMMARY_INCOMPLETE}
          fi
          [[ ${JSUB_VERSION_CONTROL} = true ]] && version_control # Do version control
        fi
      else # A line after the block of code that has just been executed
        echo ${line} >> ${JSUB_SUMMARY_INCOMPLETE}
      fi
    fi
  done < ${JSUB_PATH_TO_THIS_JOB}
  [ ${JSUB_FLAG_FAIL} = true ] && kill_this_job ${JSUB_PATH_TO_THIS_JOB} # Kill the job if a checkpoint fail occured (but let this function do logging etc first)
  return 0
}

# --- From file: /scratch/cancgene/olenive/jsub/common_functions/version_control.sh
# Function used to try to keep track of the versions of arbitrary software on the system by checking the which command and checking for the existance of git repositories.
function version_control {
  echo "called version_control"
}

# Commands taken from summary file: summaries/summaryPrefix_sample0003A.summary

#JSUB<begin-job>
#JGROUP first
bash ../../bash_scripts/concat.sh "results/outPrefix_"sample0003A_first.txt sub03X sub03Y
jcheck_file_not_empty  "results/outPrefix_"sample0003A_first.txt
bash ../../bash_scripts/concat.sh "results/outPrefix_"sample0003A_first.txt sub03Y sub03Z
jcheck_file_not_empty  "results/outPrefix_"sample0003A_first.txt

#JSUB<finish-job>
process_job
